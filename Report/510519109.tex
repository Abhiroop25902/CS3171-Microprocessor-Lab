\documentclass[a4paper]{article} %doctype define
\usepackage[a4paper,hmargin={3cm,2.5cm},vmargin={2.5cm,2.5cm}]{geometry} %setup margins
\usepackage[utf8]{inputenc} %for special character support
\usepackage{graphicx}   %for defining images root folder below
\graphicspath{ {images/} }
\usepackage{hyperref} %link table of content with actual text part

%===============For Code visibility======================
\usepackage{listings}

\usepackage{xcolor} %define custom colors
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\definecolor{compilerRed}{HTML}{cc0000}

\lstset{
    backgroundcolor=\color{white},      % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
    language=[x86masm]Assembler,                    % the language of the code
    basicstyle=\footnotesize\ttfamily,  % the size of the fonts that are used for the code
    % breakatwhitespace=false,            % sets if automatic breaks should only happen at whitespace
    % breaklines=true,                    % sets automatic line breaking
    captionpos=b,                       % sets the caption-position to bottom
    commentstyle=\color{mygreen},       % comment style
    % deletekeywords={...},               % if you want to delete keywords from the given language
    % escapeinside={\%*}{*)},             % if you want to add LaTeX within your code
    % extendedchars=true,                 % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
    firstnumber=1,                      % start line enumeration with line 1
    numbers=left,                       % where to put the line-numbers; possible values are (none, left, right)
    numberstyle=\tiny\color{mygray},    % the style that is used for the line-numbers
    numbersep=7pt,                      % how far the line-numbers are from the code
	frame=single,                       % code snippet frame, t-> top, b->bottom, l->left, r->right, single-> all around
	tabsize=4,                          % tab = (tabsize) * space
    columns=flexible,                   % two options, fixed or flexible
    keepspaces=true,                    % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
    morekeywords={*,MVI, DAD, INX, DCR, LXI, DCX, ORA, LDAX,ANI,INR,LHLD,RAL,...},               % if you want to add more keywords to the set
    rulecolor=\color{black},            % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
	showspaces=false,                   % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
    showstringspaces=false,             % underline spaces within strings only
    showtabs=false,                     % show tabs within strings adding particular underscores
    stepnumber=1,                       % the step between two line-numbers. If it's 1, each line will be numbered
    stringstyle=\color{mymauve},        % string literal style
    title=\small\lstname,               % show the filename of files included with \lstinputlisting; also try caption instead of title
	% keepspaces,
	keywordstyle=\color{blue},           % keyword style    
    morecomment=[l][\color{compilerRed}]{\#}
}
%========================== For images=================
\usepackage{caption}
\usepackage{subcaption}

\begin{document}
\input{titlepage.tex} %Title Page

\pagenumbering{roman}
\setcounter{tocdepth}{1} % only allow 1 nests
\tableofcontents
\newpage
\pagenumbering{arabic}
\setcounter{page}{1}
% ==================MAIN TEXT========================
\section[Find out the sum of the first 30 natural numbers]{Assignment 1} %[toc content]{text content}
    \subsection{Objective}
        Find out the sum of the first 30 natural numbers.
    \subsection{Tool/Experimental setup considered}
        \begin{itemize}
            \item Jubin's 8085 Simulator
        \end{itemize}
    \subsection{Procedure}
        We know that
        \[1 + 2 + 3 + ... + 29 + 30 = \frac{30 \times 29}{2} = 435 =  01D1H\]
        This result is not possible to store in a single register, so we need to use register pair to store the result.
    \subsection{Program}
        \lstinputlisting[caption=assembly program to find sum of the first 30 natural numbers]{./../Programs/Assignment 1/1_1_sum till 30.asm}
    \subsection{Experimentation}
        \begin{figure}[h!]
            \centering
            \includegraphics[width=0.7\textwidth]{Assignment 1/1_sum_till_30/registor.png}
            \caption{Register configuration after execution (observe HL)}
            \label{fg1}
        \end{figure}
    \subsection{Conclusion}
        We see that after the execution of program, the data stored in HL register pair is 01D1H, which is the hexadecimal value of 435.\\
        Hence the program is working as expected.
\newpage

\section[Find minimum and maximum number in 10-byte unsigned array]{Assignment 2} %[toc content]{text content}
    \subsection{Objective}
        From an array of 10-byte size integers (unsigned) find out the maximum and minimum.
    \subsection{Tool/Experimental setup considered}
        \begin{itemize}
            \item Jubin's 8085 Simulator
        \end{itemize}
    \subsection{Procedure}
        The idea is to linearly iterate through all the values of the arr, and update the register for minimum(C) and maximum(B) values.
    \subsection{Program}
        \lstinputlisting[caption=assembly program to find minimum and maximum number in 10-byte unsigned array]{./../Programs/Assignment 1/1_2_min-max of 10 size array.asm}
    \subsection{Experimentation}
        \begin{figure}[h!]
            \centering
            \begin{subfigure}[b]{0.4\linewidth}
                \centering
                \includegraphics[width=\linewidth]{Assignment 1/2_min-max-10-elem/test 1.png}
                \caption{result for \{5,2,3,4,F,C,7,A,B,1\}}
                \label{fg2a}
            \end{subfigure}
            \begin{subfigure}[b]{0.4\linewidth}
                \centering
                \includegraphics[width=\linewidth]{Assignment 1/2_min-max-10-elem/test 2.png}
                \caption{result for \{F,E,D,C,B,A,9,8,7,6\}}
                \label{fg2b}
            \end{subfigure}
            \caption{Result for different inputs}
            \label{fg2}
        \end{figure}
    \subsection{Conclusion}
        We see that that after program execution, B has the maximum value of array, and C has the minimum value of the array.\\
        Hence the program is working as expected.
\newpage

\section[Delay Procedure]{Assignment 3} %[toc content]{text content}
    \subsection{Objective}
        Write a routine that produces a delay. The delay value must be passed to register pair DE.
    \subsection{Tool/Experimental setup considered}
        \begin{itemize}
            \item Jubin's 8085 Simulator
        \end{itemize}
    \subsection{Procedure}
        Idea is to assign DE a very big value (say FFFF), and decrement it in a loop till DE becomes 0 to produce delay in execution.
    \subsection{Program}
        \lstinputlisting[caption=assembly program to produce delay]{./../Programs/Assignment 1/1_3_delay.asm}
    % \subsection{Experimentation}
    %     \begin{center}
    %         \fbox{\includegraphics[width=0.7\textwidth]{Assignment 1/2_min-max-10-elem/register-config.png}}\\
    %     \end{center}
    \subsection{Conclusion}
        We see that the code runs for sometime, then completes it's execution, signifying that the delay function worked and delayed execution of CPU for some time.\\
        Hence the program is working as expected.
\newpage

\section[Move block of data from location X to location Y]{Assignment 4} %[toc content]{text content}
    \subsection{Objective}
        Write a subroutine to move a block of bytes from location X to location Y.\\
        Note that the caller would specify
        \begin{itemize}
            \item X, the source address
            \item Y, the destination address
            \item Z, the block size
        \end{itemize}
        Note that X, Y and Z are 16-bit quantities.
    \subsection{Tool/Experimental setup considered}
        \begin{itemize}
            \item Jubin's 8085 Simulator
        \end{itemize}
    \subsection{Procedure}
        Start reading numbers from location X and save them to location Y, after each iteration, update address of X and Y to next byte. Do this Z times and the whole block is copied.
    \subsection{Program}
        \lstinputlisting[caption=assembly program to move block]{./../Programs/Assignment 2/2_1_move_array.asm}
        \newpage
    \subsection{Experimentation}
        \begin{figure}[h!]
            \centering
            \begin{subfigure}[b]{0.49\linewidth}
                \centering
                \includegraphics[width=\linewidth]{Assignment 2/1_Move Blocks/5 data copy.png}
                \caption{result for \{4,2,6,7,8\}}
                \label{fg3a}
            \end{subfigure}
            \begin{subfigure}[b]{0.49\linewidth}
                \centering
                \includegraphics[width=\linewidth]{Assignment 2/1_Move Blocks/10 data copy.png}
                \caption{result for \{4,2,6,7,8,1,2,4,5,6\}}
                \label{fg3b}
            \end{subfigure}
            \caption{Result for different inputs}
            \label{fg3}
        \end{figure}
    \subsection{Conclusion}
        We see that all the data from location 2500(X) to (2500 + Z) has been copied to location 4500(Y) to (4500 + Z) [Z is 5 in \ref{fg3a} and 10 in \ref{fg3b}].\\
        Hence the program is working as expected.
\newpage

\section[Check if number odd]{Assignment 5} %[toc content]{text content}
    \subsection{Objective}
        Write a function isODD(unsigned n) in assembly that takes an unsigned integer (a byte) and determines if it is odd (returns 1) or 0 if it is even.
    \subsection{Tool/Experimental setup considered}
        \begin{itemize}
            \item Jubin's 8085 Simulator
        \end{itemize}
    \subsection{Procedure}
        Odd numbers will always be in the form of $2x + 1$, which means that they will have 1 as their LSB.\\
        So we just check if $number \land 01$ is 1 or not. If the result is 1, then the number is odd, else it is even.
    \subsection{Program}
        \lstinputlisting[caption=assembly program to check if given number isOdd or not]{./../Programs/Assignment 2/2_2_is_Odd.asm}
    \subsection{Experimentation}
        \begin{figure}[h!]
            \centering
            \begin{subfigure}[b]{0.49\linewidth}
                \centering
                \includegraphics[width=\linewidth]{Assignment 2/2_isodd/odd73.png}
                \caption{result for odd number(73)}
                \label{fg4a}
            \end{subfigure}
            \begin{subfigure}[b]{0.49\linewidth}
                \centering
                \includegraphics[width=\linewidth]{Assignment 2/2_isodd/even74.png}
                \caption{result for even number(73)}
                \label{fg4b}
            \end{subfigure}
            \caption{Result for both even and odd numbers}
            \label{fg4}
        \end{figure}
    \subsection{Conclusion}
        We see that in case of odd number, C is 1 after execution and in case of even number, C is 0 after execution.\\
        Hence the program is working as expected.
\newpage

\section[Multi-Byte Addition]{Assignment 6} %[toc content]{text content}
    \subsection{Objective}
        Write a function to add two multi-byte numbers stored in location X and Y. The result is stored in X. Pass a parameter Z indicating the no. of bytes to be added.
    \subsection{Tool/Experimental setup considered}
        \begin{itemize}
            \item Jubin's 8085 Simulator
        \end{itemize}
    \subsection{Procedure}
        We simulate the default way of adding numbers, we go from right to left, adding (with carry) the numbers and adding it to stack, then we keep popping the elements and save it in X.
    \subsection{Program}
        \lstinputlisting[caption=assembly program to add multi-byte numbers]{./../Programs/Assignment 2/2_3_byte_add_right_to_left.asm}
        \newpage
    \subsection{Experimentation}
        \begin{figure}[h!]
            \centering
            \begin{subfigure}[b]{0.49\linewidth}
                \centering
                \includegraphics[width=\linewidth]{Assignment 2/3_multibyte_add/FFFFFF_FFFFFF.png}
                \caption{result for \{FF,FF,FF\} + \{FF,FF,FF\}}
                \label{fg5a}
            \end{subfigure}
            \begin{subfigure}[b]{0.49\linewidth}
                \centering
                \includegraphics[width=\linewidth]{Assignment 2/3_multibyte_add/01020304_FFFEFCFA.png}
                \caption{result for \{01,02,03,04\} + \{FF,FE,FC,FA\}}
                \label{fg5b}
            \end{subfigure}
            \caption{Result of multi-byte addition (start looking from address 8500)}
            \label{fg5}
        \end{figure}
    \subsection{Conclusion}
        We see that the result of multi-byte addition is correct.\\
        Hence the program is working as expected.
\newpage

\section[Fast Multiplication Subroutine]{Assignment 7} %[toc content]{text content}
    \subsection{Objective}
        Write a fast sub-routine to multiply 9 by 15.
    \subsection{Tool/Experimental setup considered}
        \begin{itemize}
            \item Jubin's 8085 Simulator
        \end{itemize}
    \subsection{Procedure}
        We use the Shift-and-Add Multiplication to fast multiply 15 and 9, as register size is 8 bits, we can do this multiplication by using a loop which runs 8 times, i.e O(1)\\
        This method is faster than default loop method, which run in O(min(m, n)), where m and n are the numbers that will be multiplied.
    \subsection{Program}
        \lstinputlisting[caption=assembly program to fast multiply 15 times 9]{./../Programs/Assignment 3/3_1_9_times_15_shift.asm}
    \subsection{Experimentation}
        \begin{figure}[h!]
            \centering
            \includegraphics[width=0.7\textwidth]{Assignment 3/1_9x15/9x15.png}
            \caption{Register configuration after execution (look at HL)}
            \label{fg6}
        \end{figure}
    \subsection{Conclusion}
        $9\times15=135 = 0087H$\\
        We see that the result in HL register is same as what we expected.\\
        Hence the program is working as expected.
\newpage

\section[Sort Subroutine]{Assignment 8} %[toc content]{text content}
    \subsection{Objective}
        Write a subroutine to sort a 5-element byte array (Any algorithm will do)
    \subsection{Tool/Experimental setup considered}
        \begin{itemize}
            \item Jubin's 8085 Simulator
        \end{itemize}
    \subsection{Procedure}
        We use bubble sort algorithm to sort the array.
    \subsection{Program}
        \lstinputlisting[caption=assembly program to bubble sort array]{./../Programs/Assignment 3/3_2_bubble_sort_5_elem.asm}
        \newpage
    \subsection{Experimentation}
        \begin{figure}[h!]
            \centering
            \includegraphics[width=0.7\textwidth]{Assignment 3/2_sort/mem_output.png}
            \caption{Register configuration after execution (look from address 2500)}
            \label{fg7}
        \end{figure}
    \subsection{Conclusion}
        We see that after program execution, values of address 2500 - 2504 is sorted in ascending order.\\
        Hence the program is working as expected.
\newpage

\end{document}